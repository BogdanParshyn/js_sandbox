Async
        setTimeout
        setInterval
// ========================================================================================================= // 
                Если JavaScript-кода много – его выносят в отдельный файл, который подключается в HTML:
                        Полный путь:
                        <script src="/path/to/script.js"></script> - это абсолютный путь.

                        Полный URL:
                        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>

                        Путь из текущей директории:
                        <script src="lodash.js"></script>

                Как правило, в HTML пишут только самые простые скрипты, а сложные выносят в отдельный файл.
                Браузер скачает его только первый раз и в дальнейшем, при правильной настройке сервера, будет брать из своего кеша.

                Если указан атрибут src, то содержимое тега игнорируется.
                В одном теге SCRIPT нельзя одновременно подключить внешний скрипт и указать код.
                Нужно выбрать: либо SCRIPT идёт с src, либо содержит код. 

                Если скрипт – внешний, то пока браузер не выполнит его, он не покажет часть страницы под ним.

                Атрибут async
                Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении 
                <script async src="..."> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет 
                загружен – он выполнится.

                Атрибут defer
                Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать 
                страницу, но есть два отличия от async. Но есть отличия от async:
                        - Первое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.
                        - Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.

                При одновременном указании async и defer в современных браузерах будет использован только async, 
                в IE9- – только defer (не понимает async).
                Атрибуты async/defer – только для внешних скриптов
                При попытке назначить их на обычные скрипты <script>…</script>, они будут проигнорированы.
// ========================================================================================================= // 

        setTimeout
                var timerId = setTimeout(func / code, delay[, arg1, arg2...])
                Параметры:
                - func/code - Функция или строка кода для исполнения. Строка поддерживается для совместимости, 
                            использовать её не рекомендуется.
                - delay - Задержка в миллисекундах, 1000 миллисекунд равны 1 секунде.
                - arg1, arg2… - Аргументы, которые нужно передать функции. Не поддерживаются в IE9-.
                Исполнение функции произойдёт спустя время, указанное в параметре delay.
                        function func() {
                                alert( 'Привет' );
                        }

                        setTimeout(func, 1000);
                        
        Отмена исполнения clearTimeout
                Функция setTimeout возвращает числовой идентификатор таймера timerId, который можно использовать для отмены действия.
                        var timerId = setTimeout(...);
                        clearTimeout(timerId);
                Такие разночтения вполне соответствуют стандарту просто потому, что в спецификации JavaScript про таймеры нет ни слова.
                Таймеры – это надстройка над JavaScript, которая описана в секции Timers стандарта HTML5 для браузеров и 
                в документации к Node.JS – для сервера.
// ========================================================================================================= // 

        setInterval
                Метод setInterval имеет синтаксис, аналогичный setTimeout.
                        var timerId = setInterval(func / code, delay[, arg1, arg2...])
                Смысл аргументов – тот же самый. Но, в отличие от setTimeout, он запускает выполнение функции не один раз, 
                а регулярно повторяет её через указанный интервал времени. Остановить исполнение можно 
                вызовом clearInterval(timerId).

                Следующий пример при запуске станет выводить сообщение каждые две секунды, пока не пройдёт 5 секунд:
                        // начать повторы с интервалом 2 сек
                                var timerId = setInterval(function() {
                                alert( "тик" );
                        }, 2000);

                        // через 5 сек остановить повторы
                        setTimeout(function() {
                                clearInterval(timerId);
                                alert( 'стоп' );
                        }, 5000);
// ========================================================================================================= // 

        Рекурсивный setTimeout
                Важная альтернатива setInterval – рекурсивный setTimeout:
                        /** вместо:
                        var timerId = setInterval(function() {
                                alert( "тик" );
                        }, 2000);
                        */

                        var timerId = setTimeout(function tick() {
                                alert( "тик" );
                                timerId = setTimeout(tick, 2000);
                        }, 2000);
                В коде выше следующее выполнение планируется сразу после окончания предыдущего.
                Рекурсивный setTimeout – более гибкий метод тайминга, чем setInterval, так как время до следующего выполнения 
                можно запланировать по-разному, в зависимости от результатов текущего.

                Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.
                Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва.

                - Для setTimeout – внутренняя ссылка исчезнет после исполнения функции.
                - Для setInterval – ссылка исчезнет при очистке таймера.
// ========================================================================================================= // 

        Минимальная задержка таймера
                У браузерного таймера есть минимальная возможная задержка.
                По стандарту, минимальная задержка составляет 4 мс. Так что нет разницы между setTimeout(..,1) 
                и setTimeout(..,4).
// ========================================================================================================= // 

        Реальная частота срабатывания
// ========================================================================================================= // 

        Разбивка долгих скриптов
