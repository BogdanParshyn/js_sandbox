Объект события
        Чтобы хорошо обработать событие, недостаточно знать о том, что это – «клик» или «нажатие клавиши». 
        Могут понадобиться детали: координаты курсора, введённый символ и другие, в зависимости от события.

        Детали произошедшего браузер записывает в «объект события», который передаётся первым аргументом в обработчик.
// ========================================================================================================= // 

        Свойства объекта события
               использование объекта события:

               <input type="button" value="Нажми меня" id="elem">

                <script>
                        elem.onclick = function(event) {
                                // вывести тип события, элемент и координаты клика
                                alert(event.type + " на " + event.currentTarget);
                                alert(event.clientX + ":" + event.clientY);
                }
                </script>

Свойства объекта event:
        event.type - Тип события, в данном случае click

        event.currentTarget - Элемент, на котором сработал обработчик. Значение – в точности такое же, как и у this, 
                              но бывают ситуации, когда обработчик является методом объекта и его this при помощи bind привязан 
                              к этому объекту, тогда мы можем использовать event.currentTarget.

        event.clientX / event.clientY - Координаты курсора в момент клика (относительно окна)

        Есть также и ряд других свойств, в зависимости от событий, которые мы разберём в дальнейших главах, когда будем 
        подробно знакомиться с событиями мыши, клавиатуры и так далее.

        Объект события доступен и в HTML
        При назначении обработчика в HTML, тоже можно использовать переменную event, это будет работать кросс-браузерно:
                        <input type="button" onclick="alert(event.type)" value="Тип события">
        Это возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: 
                        function(event) { alert(event.type) }. То есть, её первый аргумент называется "event".

                        Особенности IE8-
I                       E8- вместо передачи параметра обработчику создаёт глобальный объект window.event.       
                        Обработчик может обратиться к нему.
                        Работает это так:

                        elem.onclick = function() {
                                // window.event - объект события
                                alert( window.event.clientX );
                        };
// ========================================================================================================= // 

        Кроссбраузерное решение
                        element.onclick = function(event) {
                                event = event || window.event; // (*)

                                // Теперь event - объект события во всех браузерах.
                        };
                Строка (*), в случае, если функция не получила event (IE8-), использует window.event.-событие event.
                Можно написать и иначе, если мы сами не используем переменную event в замыкании:
                        element.onclick = function(e) {
                                e = e || event;

                                // Теперь e - объект события во всех браузерах.
                        };
// ========================================================================================================= // 
// ========================================================================================================= // 

Всплытие и перехват

        Всплытие
                Основной принцип всплытия:
                При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, 
                затем выше и так далее, вверх по цепочке вложенности.
                Всплытие гарантирует, что клик по внутреннему <p> вызовет обработчик onclick (если есть) сначала на самом <p>, 
                затем на элементе <div> далее на элементе <form>, и так далее вверх по цепочке родителей до самого document.

                Поэтому если в примере выше кликнуть на P, то последовательно выведутся alert: p → div → form.

                Этот процесс называется всплытием, потому что события «всплывают» от внутреннего элемента вверх через родителей, 
                подобно тому, как всплывает пузырек воздуха в воде.

                Всплывают почти все события. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. 
                В дальнейших главах мы будем детально знакомиться с различными событиями и увидим ещё примеры.

        Целевой элемент event.target    
                На каком бы элементе мы ни поймали событие, всегда можно узнать, где конкретно оно произошло.
                Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как 
                event.target.

                Отличия от this (=event.currentTarget):
                        - event.target – это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен.
                        - this – это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.
                Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. 
                Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик. При этом:
                        - this (=event.currentTarget) всегда будет сама форма, так как обработчик сработал на ней.
                        - event.target будет содержать ссылку на конкретный элемент внутри формы, самый вложенный, 
                          на котором произошёл клик.
                        
                Возможна и ситуация, когда event.target и this – один и тот же элемент, например если в форме нет других тегов 
                и клик был на самом элементе <form>.
// ========================================================================================================= // 
        
        Прекращение всплытия
                Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента <html>, а затем до 
                document, а иногда даже до window, вызывая все обработчики на своем пути.

                Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
        event.stopPropagation().        
                Для остановки всплытия нужно вызвать метод event.stopPropagation().
                Например, здесь при клике на кнопку обработчик body.onclick не сработает:
                        <body onclick="alert('сюда обработка не дойдёт')">
                                <button onclick="event.stopPropagation()">Кликни меня</button>
                        </body>
                
        event.stopImmediatePropagation()
                Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
                То есть, stopPropagation препятствует продвижению события дальше, но на текущем элементе все обработчики отработают.
                Для того, чтобы полностью остановить обработку, современные браузеры поддерживают 
                метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку 
                событий на текущем элементе.

                Проблема в том, что stopPropagation убивает всякую возможность отследить событие сверху, а это бывает нужно 
                для реализации чего-нибудь «эдакого», что к меню отношения совсем не имеет.
// ========================================================================================================= // 

        Погружение
                В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».
                Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.
                Строго говоря, стандарт выделяет целых три стадии прохода события:
                        - Событие сначала идет сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).
                        - Событие достигло целевого элемента. Это – «стадия цели» (target stage).
                        - После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).
                То есть, при клике на TD событие путешествует по цепочке родителей сначала вниз к элементу («погружается»), 
                а потом наверх («всплывает»), по пути задействуя обработчики.
                Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно 
                для нас.

                Обработчики, добавленные через on...-свойство, ничего не знают о стадии перехвата, а начинают работать со всплытия.

                Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener:
                        - Если аргумент true, то событие будет перехвачено по дороге вниз.
                        - Если аргумент false, то событие будет поймано при всплытии.

                Есть события, которые не всплывают, но которые можно перехватить
                Бывают события, которые можно поймать только на стадии перехвата, а на стадии всплытия – нельзя…
                Например, таково событие фокусировки на элементе onfocus. Конечно, это большая редкость, такое исключение 
                существует по историческим причинам.

                Обработчики сработают в порядке «сверху-вниз»: FORM → DIV → P.
                JS-код здесь такой:
                        var elems = document.querySelectorAll('form,div,p');

                        // на каждый элемент повесить обработчик на стадии перехвата
                        for (var i = 0; i < elems.length; i++) {
                                elems[i].addEventListener("click", highlightThis, true);
                        }
                Никто не мешает назначить обработчики для обеих стадий, вот так:
                        var elems = document.querySelectorAll('form,div,p');

                        for (var i = 0; i < elems.length; i++) {
                                elems[i].addEventListener("click", highlightThis, true);
                                elems[i].addEventListener("click", highlightThis, false);
                        }
                Должно быть FORM → DIV → P → P → DIV → FORM. Заметим, что элемент <p> участвует в обоих стадиях.

                Как видно из примера, один и тот же обработчик можно назначить на разные стадии. При этом номер текущей стадии он, 
                при необходимости, может получить из свойства event.eventPhase (=1, если погружение, =3, если всплытие).

        Отличия IE8-
                Чтобы было проще ориентироваться, я собрал отличия IE8-, которые имеют отношение ко всплытию, в одну секцию.
                Их знание понадобится, если вы решите писать на чистом JS, без фреймворков и вам понадобится поддержка IE8-.

                Нет свойства event.currentTarget
                Обратим внимание, что при назначении обработчика через onсвойство у нас есть this, поэтому event.currentTarget, 
                как правило, не нужно, а вот при назначении через attachEvent обработчик не получает this, так что текущий 
                элемент, если нужен, можно будет взять лишь из замыкания.

                Вместо event.target в IE8- используется event.srcElement
                Если мы пишем обработчик, который будет поддерживать и IE8- и современные браузеры, то можно начать его так:

                        elem.onclick = function(event) {
                                event = event || window.event;
                                var target = event.target || event.srcElement;

                                // ... теперь у нас есть объект события и target
                                ...
                        }
                Для остановки всплытия используется код event.cancelBubble=true.
                Кросс-браузерно остановить всплытие можно так:
                        event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);