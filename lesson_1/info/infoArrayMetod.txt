Массивы: методы
// ========================================================================================================= // 

        Метод split
                метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s.
                В примере ниже таким разделителем является строка из запятой и пробела. 
                        var names = 'Маша, Петя, Марина, Василий';

                        var arr = names.split(', ');

                        for (var i = 0; i < arr.length; i++) {
                                alert( 'Вам сообщение ' + arr[i] );
                        }

                У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. 
                Если их больше, чем указано – остаток массива будет отброшен:
                        alert( "a,b,c,d".split(',', 2) ); // a,b

                Разбивка по буквам
                Вызов split с пустой строкой разобьёт по буквам:
// ========================================================================================================= // 

        Метод join
                Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, 
                используя str как разделитель.
                        var arr = ['Маша', 'Петя', 'Марина', 'Василий'];

                        var str = arr.join(';');

                        alert( str ); // Маша;Петя;Марина;Василий

                new Array + join = Повторение строки
                        alert( new Array(4).join("ля") ); // ляляля
                Как видно, new Array(4) делает массив без элементов длины 4, который join объединяет в строку, 
                вставляя между его элементами строку "ля".
// ========================================================================================================= //    
     
        Удаление из массива
                Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete:
                        var arr = ["Я", "иду", "домой"];

                        delete arr[1]; // значение с индексом 1 удалено

                        // теперь arr = ["Я", undefined, "домой"];
                        alert( arr[1] ); // undefined
                Да, элемент удален из массива, но не так, как нам этого хочется. Образовалась «дырка».
                Поэтому для удаления используются специальные методы: 
                        из начала – shift, 
                        с конца – pop, 
                        а из середины – splice, с которым мы сейчас познакомимся.
// ========================================================================================================= //  

        Метод splice
                Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, 
                вставлять элементы, заменять элементы – по очереди и одновременно.
                        arr.splice(index[, deleteCount, elem1, ..., elemN])
                Удалить deleteCount элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. 
                Возвращает массив из удалённых элементов.
                        var arr = ["Я", "изучаю", "JavaScript"];
                        arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
                        alert( arr ); //  осталось ["Я", "JavaScript"]
                
                В следующем примере мы удалим 3 элемента и вставим другие на их место:
                        var arr = ["Я", "сейчас", "изучаю", "JavaScript"];

                        // удалить 3 первых элемента и добавить другие вместо них
                        arr.splice(0, 3, "Мы", "изучаем")

                        alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"]

                Здесь видно, что splice возвращает массив из удаленных элементов:
                        var arr = ["Я", "сейчас", "изучаю", "JavaScript"];

                        // удалить 2 первых элемента
                        var removed = arr.splice(0, 2);

                        alert( removed ); // "Я", "сейчас" <-- array of removed elements

                Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
                        var arr = ["Я", "изучаю", "JavaScript"];

                        // с позиции 2
                        // удалить 0
                        // вставить "сложный", "язык"
                        arr.splice(2, 0, "сложный", "язык");

                        alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
                
                Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
                        var arr = [1, 2, 5]

                        // начиная с позиции индексом -1 (перед последним элементом)
                        // удалить 0 элементов,
                        // затем вставить числа 3 и 4
                        arr.splice(-1, 0, 3, 4);

                        alert( arr ); // результат: 1,2,3,4,5
// ========================================================================================================= //  

        Метод slice
                Метод slice(begin, end) копирует участок массива от begin до end, не включая end. 
                Исходный массив при этом не меняется.
                        var arr = ["Почему", "надо", "учить", "JavaScript"];

                        var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)

                        alert( arr2 ); // надо, учить

                Аргументы ведут себя так же, как и в строковом slice:
                Если не указать end – копирование будет до конца массива:
                        var arr = ["Почему", "надо", "учить", "JavaScript"];

                        alert( arr.slice(1) ); // взять все элементы, начиная с номера 1
                
                Можно использовать отрицательные индексы, они отсчитываются с конца:
                        var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше

                Если вообще не указать аргументов – скопируется весь массив:
                        var fullCopy = arr.slice();
                Синтаксис метода slice одинаков для строк и для массивов. Тем проще его запомнить.
// ========================================================================================================= //  

        Сортировка, метод sort(fn)
                Метод sort() сортирует массив на месте. Например:
                        var arr = [ 1, 2, 15 ];

                        arr.sort();

                        alert( arr );  // 1, 15, 2
                Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.
                Поэтому и порядок у них строковый, ведь "2" > "15".

        Свой порядок сортировки
                Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, 
                которая умеет сравнивать их.
                Если эту функцию не указать, то элементы сортируются как строки.
                        function compareNumeric(a, b) {
                                if (a > b) return 1;
                                if (a < b) return -1;
                        }

                        var arr = [ 1, 2, 15 ];

                        arr.sort(compareNumeric);

                        alert(arr);  // 1, 2, 15
                Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, без вызова через скобки. 
                Был бы ошибкой следующий код:
                        arr.sort( compareNumeric() );  // не сработает
                Кстати, те значения, с которыми sort вызывает функцию сравнения, можно увидеть, если вставить в неё alert:
                        [1, -2, 15, 2, 0, 8].sort(function(a, b) {
                                alert( a + " <> " + b );
                        });

                Функцию compareNumeric для сравнения элементов-чисел можно упростить до одной строчки.
                        function compareNumeric(a, b) {
                                return a - b;
                        }
                Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, 
                если наоборот, и 0, если числа равны.
// ========================================================================================================= //  

        reverse
                Метод arr.reverse() меняет порядок элементов в массиве на обратный.
                        var arr = [1, 2, 3];
                        arr.reverse();

                        alert( arr ); // 3,2,1
// ========================================================================================================= //  

        concat
                Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, 
                а также value1, value2, ... valueN.
                        var arr = [1, 2];
                        var newArr = arr.concat(3, 4);

                        alert( newArr ); // 1,2,3,4
                У concat есть одна забавная особенность. Если аргумент concat – массив, то concat добавляет элементы из него.
                        var arr = [1, 2];

                        var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)

                        alert( newArr ); // 1,2,3,4,5
/ ========================================================================================================= //  

        indexOf/lastIndexOf
                Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, 
                если его нет.
                Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
                Для поиска используется строгое сравнение ===.
                        var arr = [1, 0, false];

                        alert( arr.indexOf(0) ); // 1
                        alert( arr.indexOf(false) ); // 2
                        alert( arr.indexOf(null) ); // -1
                Как вы могли заметить, по синтаксису он полностью аналогичен методу indexOf для строк.
                Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, 
                если он указан.

                Методы indexOf/lastIndexOf осуществляют поиск перебором
                Если нужно проверить, существует ли значение в массиве – его нужно перебрать. Только так. 
                Внутренняя реализация indexOf/lastIndexOf осуществляет полный перебор, аналогичный циклу for по массиву. 
                Чем длиннее массив, тем дольше он будет работать.
// ========================================================================================================= //  
        
        Object.keys(obj)
                Ранее мы говорили о том, что свойства объекта можно перебрать в цикле for..in.
                        var user = {
                                name: "Петя",
                                age: 30
                        }

                        var keys = Object.keys(user);

                        alert( keys ); // name, age
// ========================================================================================================= //  
        
        Итого
        Методы массивов:
                - push/pop, shift/unshift, splice – для добавления и удаления элементов.

                - join/split – для преобразования строки в массив и обратно.

                - slice – копирует участок массива.

                - sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.

                - reverse – меняет порядок элементов на обратный.

                - concat – объединяет массивы.

                - indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-).

        Дополнительно:
                - Object.keys(obj) возвращает массив свойств объекта.