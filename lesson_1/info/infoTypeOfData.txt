// Функция по добавлению тега в HTML. 

function addScript(src){
    var script = document.createElement('script'); // Так мы создаем тег (script) через переменную.
    script.src = src; //указываем чему будет равно значение src.
    script.async = false; // чтобы гуказарантировать порядок
    document.body.appendChild(script); // А так мы добавляем к boby созданый выше тег в HTML.
    //document.head.appendChild(script); // А так мы добавляем к head созданый выше тег в HTML.
    script.innerHTML = "456"; // Так мы добавляем что хотим в тег.
  }
  
  addScript('1.js'); // Это вызов функции с указанием названия значения атрибута src, в нашем случае название файла, который мы хотим подключить.

// ========================================================================================================= //

// Виды данных:
// ========================================================================================================= //
Number и хранятся в 64-битном формате IEEE-754, также известном как «double precision».


        alert( "нечисло" * 2 ); // NaN, ошибка

        alert( 0xFF ); // 255 в шестнадцатиричной системе

        // еще пример научной формы: 3 с 5 нулями
        alert( 3e5 ); // 300000

        // здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
        alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль
        // ========================================================================================================= //

        alert( 1 / 0 ); // Infinity
        alert( 12345 / 0 ); // Infinity
        Infinity больше любого числа.
        alert( Infinity > 1234567890 ); // true
        alert( Infinity + 5 == Infinity ); // true
        alert( -1 / 0 ); // -Infinity
        alert( 1e500 ); // Infinity
        // ========================================================================================================= //

        alert( 0 / 0 ); // NaN
        Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.
        Проверка на NaN:
        var n = 0 / 0;

        alert( isNaN(n) ); // true
        alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12

        Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.
        alert( NaN + 1 ); // NaN
        Если аргумент isNaN – не число, то он автоматически преобразуется к числу.
        Но пустая строка и пробел равны "0", а значит являются числом.
        var n = 0 / 0;
        if (n !== n) alert( 'n = NaN!' );

        Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
        alert( isFinite(1) ); // true
        alert( isFinite(Infinity) ); // false
        alert( isFinite(NaN) ); // false   
        

        // ========================================================================================================= //

        Унарный плюс преобразовывает значение в число
        Если в значении кроме чисел есть что-то другое, то результат будет NaN:
        alert( +"12test" ); // NaN
        alert( +"  -12" ); // -12
        alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
        alert( +"" ); // 0, пустая строка становится нулем
        alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
        alert( '12.34' / "-2" ); // -6.17
        // ========================================================================================================= //

        Мягкое преобразование: parseInt и parseFloat
        alert(+"12px") // NaN
        alert( parseInt('12px') ); // 12 - читает пока не дойдет до буквы или иного знака, отлчающегося от числа.
        parseInt читает из строки целое число, а parseFloat – дробное.
        alert( parseInt('12px') ) // 12, ошибка на символе 'p'
        alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
        alert( parseInt('a123') ); // NaN - если первый символ буква или иной знак, отличающийся от числа.
        alert( parseInt('FF', 16) ); // 255 - шестнадцатиричная система исчисления.

        Проверка на число:
        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
          }

        // ========================================================================================================= //
        toString(система счисления):

        10-ти ричная система.
        var n = 255;
        alert( n.toString(16) ); // ff

        побитовых операций:
        var n = 4;
        alert( n.toString(2) ); // 100

        36 (по количеству букв в английском алфавите – 26, вместе с цифрами, которых 10) 
        var n = 1234567890;
        alert( n.toString(36) ); // kf12oi
        // ========================================================================================================= //

        Округление:

        Math.floor - Округляет вниз
        Math.ceil - Округляет вверх
        Math.round - Округляет до ближайшего целого

        Округление битовыми операторами:

        двойное битовое НЕ – округляет его:
        alert( ~~12.3 ); // 12

        исключающее ИЛИ, "^":
        alert( 12.3 ^ 0 ); // 12
        alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
        var x = a * b / c ^ 0; // читается как "a * b / c и округлить"

        Округление до заданной точности:
        var n = 3.456;
        alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46

        num.toFixed(precision) - который округляет число num до точности precision и возвращает результат в виде строки:
        var n = 12.34;
        alert( n.toFixed(1) ); // "12.3"
        var n = 12.36;
        alert( n.toFixed(1) ); // "12.4"
        var n = 12.34;
        alert( n.toFixed(5) ); // "12.34000", добавлены нули до 5 знаков после запятой
        Если хотим получить не строку, а число, то в начале добавляем "+":
        var n = 12.34;
        alert( +n.toFixed(5) ); // 12.34

        Другие математические методы:
        Тригонометрия: Встроенные функции для тригонометрических вычислений:

        Math.acos(x) - Возвращает арккосинус x (в радианах)
        Math.asin(x) - Возвращает арксинус x (в радианах)
        Math.atan(x) - Возвращает арктангенс x (в радианах)
        Math.atan2(y, x) - Возвращает угол до точки (y, x). Описание функции: Atan2.
        Math.sin(x) - Вычисляет синус x
        Math.cos(x) - Вычисляет косинус x
        Math.tan(x) - Возвращает тангенс x

        Функции общего назначения:
        Math.sqrt(x) - Возвращает квадратный корень из x.
        Math.log(x) - Возвращает натуральный (по основанию e) логарифм x.
        Math.pow(x, exp) - Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными 
                           и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
        Math.abs(x) - Возвращает абсолютное значение числа
        Math.exp(x) - Возвращает ex, где e – основание натуральных логарифмов.
        Math.max(a, b, c...) - Возвращает наибольший из списка аргументов
        Math.min(a, b, c...) - Возвращает наименьший из списка аргументов
        Math.random() - Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). 
                        Генератор случайных чисел инициализуется текущим временем.

        Форматирование: Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():
        var number = 123456789;
        alert( number.toLocaleString() ); // 123 456 789
// ========================================================================================================= //

Строка «string»:
        \b	Backspace
        \f	Form feed
        \n	New line перевод строки на новую
        \r	Carriage return
        \t	Tab
        \uNNNN	Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, 
                `\u00A9` -- юникодное представление символа копирайт ©  

        Экранирование: \'
        Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт:
        alert( "\a" ); // a
        // идентично alert(  "a"  );
        // ========================================================================================================= //

      Методы и свойства:
            Длина length:
            var str = "My\n"; // 3 символа. Третий - перевод строки
            alert( str.length ); // 3


            Доступ к символам: charAt(позиция)
            var str = "jQuery";
            alert( str.charAt(0) ); // "j"
                    или
            var str = "Я - современный браузер!";
            alert( str[0] ); // "Я"
            Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, 
            а скобки – undefined:


            Изменения строк
            var str = "строка";
            str = str[3] + str[4] + str[5];
            alert( str ); // ока


            Смена регистра - Методы toLowerCase() и toUpperCase()
            alert( "Интерфейс".toUpperCase() ); // ИНТЕРФЕЙС
            alert( "Интерфейс" [0].toLowerCase() ); // 'и'


            Поиск подстроки - метод indexOf(подстрока[, начальная_позиция]).
                              Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено.

            var str = "Widget with id";

            alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
            alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
            alert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр
            alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

            Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.

            Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – 
            начинаем следующий поиск со следующей

            var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
            var target = "Иа"; // цель поиска

            var pos = 0;
            while (true) {
              var foundPos = str.indexOf(target, pos);
              if (foundPos == -1) break;

              alert( foundPos ); // нашли на этой позиции
              pos = foundPos + 1; // продолжить поиск со следующей
            }

            или так

            var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
            var target = "Иа"; // цель поиска

            var pos = -1;
            while ((pos = str.indexOf(target, pos + 1)) != -1) {
              alert( pos );
            }
            // ========================================================================================================= //

            Взятие подстроки: substring, substr, slice

            substring(start [, end]) - Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.

            var str = "stringify";
            alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.

            Если аргумент end отсутствует, то идет до конца строки
            var str = "stringify";
            alert(str.substring(2)); // ringify, символы с позиции 2 до конца

            Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
            alert( "testme".substring(-2) ); // "testme", -2 становится 0
            Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
            alert( "testme".substring(4, -1) ); // "test"
            // -1 становится 0 -> получили substring(4, 0)
            // 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
            // ========================================================================================================= //

            substr(start [, length]) - Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную 
                                       позицию, а количество символов.
            var str = "stringify";
            str = str.substr(2,4); // ring, со 2-й позиции 4 символа
            alert(str)

            Если второго аргумента нет – подразумевается «до конца строки».
            // ========================================================================================================= //

            slice(start [, end]) - Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – 
                                   такой же как в substring.
            Отрицательные значения отсчитываются от конца строки:
            alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
            alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
            // ========================================================================================================= //

            Есть и другие методы, например trim обрезает пробелы с начала и конца строки.
            Больше информации о методах для строк можно получить в справочнике: http://javascript.ru/String.

        // ========================================================================================================= //   

      Кодировка Юникод:
            alert( 'а' > 'Я' ); // true
            alert( 'ё' > 'я' ); // true

            Метод String.fromCharCode(code) - Возвращает символ по коду code:
            alert( String.fromCharCode(1072) ); // 'а'

            Метод str.charCodeAt(pos) - метод для получения цифрового кода из символа, Возвращает код символа на позиции pos:
            alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'

            Символы сравниваются не по алфавиту, а по коду. У кого код больше – тот и больше
            Строчные буквы идут после заглавных, поэтому они всегда больше.
            В частности, 'а'(код 1072) > 'Я'(код 1071).
            То же самое происходит и в английском алфавите, там 'a' > 'Z'.
            Ряд букв, например ё, находятся вне основного алфавита.

                    Юникод в HTML
                    Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» 
                    (numeric character reference).            
                    Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' 
                    в виде числовой ссылки: &#1072;.            
                    Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.            
                    В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (&#x2702;), дроби: ½ (&#xBD;) 
                    ¾ (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.
            
            Посимвольное сравнение:
            Сравниваются все символы по очереди, пока символы не будут наконец разными, и тогда какой символ больше – та строка 
            и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились 
            в обеих – они равны.
            "Вася" > "Ваня" // true, т.к. начальные символы совпадают, а потом 'с' > 'н'
            "Дома" > "До" // true, т.к. начало совпадает, но в 1-й строке больше символов        

            alert( "2" > "14" ); // true, так как это строки, и для первых символов верно "2" > "1"
            Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:
            alert( 2 > "14" ); // false

            Правильное сравнение
            var str = "Ёлки";
            alert( str.localeCompare("Яблони") ); // -1
            Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 
                                                       1, если str1 > str2,
                                                       0, если они равны.
// ========================================================================================================= //

Булевый (логический) тип «boolean»
        У него всего два значения: true (истина) и false (ложь).
        Как правило, такой тип используется для хранения значения типа да/нет, например:
        var checked = true; // поле формы помечено галочкой
        checked = false;    // поле формы не содержит галочки
// ========================================================================================================= //

Специальное значение «null»
        Значение null не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного 
        значения null:
        var age = null;
        В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. 
        Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
        В частности, код выше говорит о том, что возраст age неизвестен.
// ========================================================================================================= //

Специальное значение «undefined»:
        Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет 
        смысл «значение не присвоено».
        Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined:
            var x;
            alert( x ); // выведет "undefined"
         Можно присвоить undefined и в явном виде, хотя это делается редко:
            var x = 123;
            x = undefined;
            alert( x ); // "undefined"
          В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную 
          «пустого» или «неизвестного» значения используется null.
// ========================================================================================================= //

Объекты «object»:
        Первые 5 типов называют «примитивными».
        Особняком стоит шестой тип: «объекты».
        Он используется для коллекций данных и для объявления более сложных сущностей.
        Объявляются объекты при помощи фигурных скобок {...}, например:
            var user = { name: "Вася" };
// ========================================================================================================= //

Оператор typeof:
        Оператор typeof возвращает тип аргумента.
        У него есть два синтаксиса: со скобками и без:
            Синтаксис оператора: typeof x.
            Синтаксис функции: typeof(x).
        Работают они одинаково, но первый синтаксис короче.
        Результатом typeof является строка, содержащая тип:
              typeof undefined // "undefined"
              typeof 0 // "number"
              typeof true // "boolean"
              typeof "foo" // "string"
              typeof {} // "object"
              typeof null // "object"  (1)
              typeof function(){} // "function"  (2)
        Последние две строки помечены, потому что typeof ведет себя в них по-особому.

        (1)Результат typeof null == "object" – это официально признанная ошибка в языке, которая сохраняется для совместимости. 
        На самом деле null – это не объект, а отдельный тип данных.

        (2)Функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но typeof выделяет функции отдельно, 
        возвращая для них "function". На практике это весьма удобно, так как позволяет легко определить функцию.

              NaN == NaN; // false
              NaN === NaN; // false
        
              1 / 0; // Infinity
              typeof 1 / 0; // NaN
              typeof 1 / 0 == NaN; // false
              typeof(1 / 0); // "number"
        
              typeof 1 / "text"; // NaN
              typeof(1 / "text"); // "number"
              typeof 1 / "text" == NaN; // false
// ========================================================================================================= //
